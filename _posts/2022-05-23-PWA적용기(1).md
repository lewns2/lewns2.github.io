---
title: PWA 도입하기 (1) - CRA 4.x 버전에서 PWA 도입하기
description: 한줌 프로젝트를 진행하며 오프라인에서도 동작하는 웹앱을 만들기 위한 과정을 서술합니다.
categories:
 - 프로젝트
tags: web react redux
---

## Progressive Web App(이하 PWA)?
PWA는 'Progressive Web App'의 줄인 말로, 모바일 사이트에서 네이티브 앱과 같은 사용자 경험을 제공하는 기술입니다.

PWA에서 구현할 수 있는 기능
1. 푸시 알림
2. 아이콘을 홈 화면에 추가(모바일)
3. 표시속도의 고속화
4. 오프라인에서 열람이 가능
5. 검색 엔진 노출


## 왜 PWA 도입했을까?
가장 주된 이유는 사용자의 재참여율을 높이기 위한 최적의 방안이라고 생각했기 때문입니다.
PWA 도입 시, 앱과 같이 홈 화면에 아이콘 추가 및 푸시 알림을 통해 사용자가 앱을 사용하지 않는 시간에도 동작하여 지속적인 알 (백그라운드에서 동작하기 때문에 푸시 알림, 홈화면에 추가를 통해 사용자의 접촉 기회를 늘릴 수 있다.)

부차적인 이유로는, PWA의 프리캐시 기능을 통해 읽기 속도를 개선할 수 있고, 구글의 Workbox의 캐싱 전략을 통해 렌더링 속도를 향상시키기 위함입니다.

## PWA 도입 시, 주의할 점
SSL화가 필요합니다.
PWA 도입 시, 사용되는 서비스 워커(Service Worker)는 보안 상의 이유로 HTTPS 프로토콜에서만 실행됩니다. (localhost는 가능합니다.)


## Service Worker : 프로그래밍 가능한 네트워크 프록시
서비스워커(Service Worker)는 브라우저와 네트워크 사이의 가상 프록시입니다. <br>
이를 활용하여 웹 사이트의 정적 파일을 캐싱(caching)하여 페이지를 빠르개 로딩을 할 수도 있으며, 
사용자의 기기가 오프라인 상태라 하더라도 백그라운드에서 동기화하는 등  
이를 활용하여 `웹 사이트의 자원을 적절히 캐싱`, `사용자의 기기가 오프라인일 때 이를 사용할 수 있도록 하는 것`

수명 주기(Life Cycle)
서비스워커의 수명 주기는 웹 애플리케이션과 전혀 관련이 없습니다.

등록 &rarr; 서비스 워커(js 파일) &rarr; 다운로드 &rarr; 설치 &rarr; 활성화 

1. JavaScript를 활용하여 서비스 워커 등록
2. 서비스 워커 파일을 자동으로 다운로드 후 설치 (브라우저가 백그라운드에서 설치하도록 지시)
3. 활성화 프로세스

## 프로젝트에 적용하기

이미 React에서 PWA 적용을 위한 환경을 모두 제공해주고 있어 PWA를 적용하는 것은 어렵지 않습니다.

### Service Worker

### PWA로 프로젝트 생성
만약, 아직 프로젝트 생성 전이시라면 [Making a Progressive Web App](https://create-react-app.dev/docs/making-a-progressive-web-app/)을 참고하여 바로 PWA환경이 갖추어진 프로젝트를 생성하실 수 있습니다.
하지만, 이미 기존의 프로젝트가 있으신 분들이라면 간단한 작업이 필요합니다.

### CRA(create-react-app)환경에서 적용하기
시작하기 앞서, create-react-app 3.x.x 버전과 4.x.x 버전을 확인해주시기 바랍니다.

중요!
3.x.x 버전까지는 서비스 워커 파일을 직접적으로 제공하였다고 합니다.
하지만 CRA 버전이 업데이트되면서 이제 서비스 워커 파일을 별로 제공하지 않습니다.
 - 관련 글 : [CRA 4 does not generate service-worker on build](https://github.com/facebook/create-react-app/issues/10032)

3.x.x 버전인 경우, 리액트 어플리케이션 생성 시, 아래와 같은 구조를 띄고 있을 것입니다.
```
├── README.md
├── node_modules
├── package.json
├── .gitignore
├── build
├── public
│   ├── favicon.ico
│   ├── index.html
│   └── manifest.json
└── src
    ├── App.css
    ├── App.js
    ├── App.test.js
    ├── index.css
    ├── index.js
    ├── logo.svg
    └── serviceWorker.js
```

서비스워커 파일이 존재하는 것을 확인할 수 있고, 이제 이를 등록하기만 하면 됩니다.
`src/index.js`의
```javascript
serviceWorker.unregister()
```
를
```javascript
serviceWorker.register()
```
바꿔주시면 됩니다. 이제 서비스 워커를 사용할 준비를 마쳤습니다.


4.x.x 버전인 경우, 리액트 어플리케이션 생성 시, 서비스 워커 파일을 찾아볼 수 없습니다.
그래서 우리는 별도로 새롭게 PWA 프로젝트를 생성한 후, `service-worker.js` 와 `serviceWorkerRegistration.js ` 파일을 복사하여 가져와야합니다.

새롭게 PWA 환경의 리액트 어플리케이션을 생성해줍니다.

```bash
npx create-react-app my-app --template cra-template-pwa
```

`service-worker.js` 와 `serviceWorkerRegistration.js ` 파일을 복사하여 내가 적용하고자 하는 프로젝트에 가져옵니다.

```bash
├── README.md
├── node_modules
├── package.json
├── .gitignore
├── build
├── public
│   ├── favicon.ico
│   ├── index.html
│   └── manifest.json
└── src
    ├── App.css
    ├── App.js
    ├── App.test.js
    ├── index.css
    ├── index.js
    ├── logo.svg
    └── service-worker.js
    └── serviceWorkerRegistration.js
```


마찬가지로, 이제 `src/index.js`에서 serviceWorkerRegistration.js를 불러와 등록합니다.

```javascript
import * as serviceWorkerRegistration from './serviceWorkerRegistration';

...

serviceWorkerRegistration.register();
```


`src/service-worker.js`
```javascript
/* eslint-disable no-restricted-globals */

// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.
// You can also remove this file if you'd prefer not to use a
// service worker, and the Workbox build step will be skipped.

import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate } from 'workbox-strategies';

clientsClaim();

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
precacheAndRoute(self.__WB_MANIFEST);

// Set up App Shell-style routing, so that all navigation requests
// are fulfilled with your index.html shell. Learn more at
// https://developers.google.com/web/fundamentals/architecture/app-shell
const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$');
registerRoute(
  // Return false to exempt requests from being fulfilled by index.html.
  ({ request, url }) => {
    // If this isn't a navigation, skip.
    if (request.mode !== 'navigate') {
      return false;
    } // If this is a URL that starts with /_, skip.

    if (url.pathname.startsWith('/_')) {
      return false;
    } // If this looks like a URL for a resource, because it contains // a file extension, skip.

    if (url.pathname.match(fileExtensionRegexp)) {
      return false;
    } // Return true to signal that we want to use the handler.

    return true;
  },
  createHandlerBoundToURL(process.env.PUBLIC_URL + '/index.html')
);

// An example runtime caching route for requests that aren't handled by the
// precache, in this case same-origin .png requests like those from in public/
registerRoute(
  // Add in any other file extensions or routing criteria as needed.
  ({ url }) => url.origin === self.location.origin && url.pathname.endsWith('.png'), // Customize this strategy as needed, e.g., by changing to CacheFirst.
  new StaleWhileRevalidate({
    cacheName: 'images',
    plugins: [
      // Ensure that once this runtime cache reaches a maximum size the
      // least-recently used images are removed.
      new ExpirationPlugin({ maxEntries: 50 }),
    ],
  })
);

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

// Any other custom service worker logic can go here.

```

`src/serviceWorkerRegistration.js`
```javascript
// This optional code is used to register a service worker.
// register() is not called by default.

// This lets the app load faster on subsequent visits in production, and gives
// it offline capabilities. However, it also means that developers (and users)
// will only see deployed updates on subsequent visits to a page, after all the
// existing tabs open on the page have been closed, since previously cached
// resources are updated in the background.

// To learn more about the benefits of this model and instructions on how to
// opt-in, read https://cra.link/PWA

const isLocalhost = Boolean(
  window.location.hostname === 'localhost' ||
    // [::1] is the IPv6 localhost address.
    window.location.hostname === '[::1]' ||
    // 127.0.0.0/8 are considered localhost for IPv4.
    window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)
);

export function register(config) {
  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {
    // The URL constructor is available in all browsers that support SW.
    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);
    if (publicUrl.origin !== window.location.origin) {
      // Our service worker won't work if PUBLIC_URL is on a different origin
      // from what our page is served on. This might happen if a CDN is used to
      // serve assets; see https://github.com/facebook/create-react-app/issues/2374
      return;
    }

    window.addEventListener('load', () => {
      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;

      if (isLocalhost) {
        // This is running on localhost. Let's check if a service worker still exists or not.
        checkValidServiceWorker(swUrl, config);

        // Add some additional logging to localhost, pointing developers to the
        // service worker/PWA documentation.
        navigator.serviceWorker.ready.then(() => {
          console.log(
            'This web app is being served cache-first by a service ' +
              'worker. To learn more, visit https://cra.link/PWA'
          );
        });
      } else {
        // Is not localhost. Just register service worker
        registerValidSW(swUrl, config);
      }
    });
  }
}

function registerValidSW(swUrl, config) {
  navigator.serviceWorker
    .register(swUrl)
    .then((registration) => {
      registration.onupdatefound = () => {
        const installingWorker = registration.installing;
        if (installingWorker == null) {
          return;
        }
        installingWorker.onstatechange = () => {
          if (installingWorker.state === 'installed') {
            if (navigator.serviceWorker.controller) {
              // At this point, the updated precached content has been fetched,
              // but the previous service worker will still serve the older
              // content until all client tabs are closed.
              console.log(
                'New content is available and will be used when all ' +
                  'tabs for this page are closed. See https://cra.link/PWA.'
              );

              // Execute callback
              if (config && config.onUpdate) {
                config.onUpdate(registration);
              }
            } else {
              // At this point, everything has been precached.
              // It's the perfect time to display a
              // "Content is cached for offline use." message.
              console.log('Content is cached for offline use.');

              // Execute callback
              if (config && config.onSuccess) {
                config.onSuccess(registration);
              }
            }
          }
        };
      };
    })
    .catch((error) => {
      console.error('Error during service worker registration:', error);
    });
}

function checkValidServiceWorker(swUrl, config) {
  // Check if the service worker can be found. If it can't reload the page.
  fetch(swUrl, {
    headers: { 'Service-Worker': 'script' },
  })
    .then((response) => {
      // Ensure service worker exists, and that we really are getting a JS file.
      const contentType = response.headers.get('content-type');
      if (
        response.status === 404 ||
        (contentType != null && contentType.indexOf('javascript') === -1)
      ) {
        // No service worker found. Probably a different app. Reload the page.
        navigator.serviceWorker.ready.then((registration) => {
          registration.unregister().then(() => {
            window.location.reload();
          });
        });
      } else {
        // Service worker found. Proceed as normal.
        registerValidSW(swUrl, config);
      }
    })
    .catch(() => {
      console.log('No internet connection found. App is running in offline mode.');
    });
}

export function unregister() {
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.ready
      .then((registration) => {
        registration.unregister();
      })
      .catch((error) => {
        console.error(error.message);
      });
  }
}

```

`src/index.js`
```javascript
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';
import * as serviceWorkerRegistration from './serviceWorkerRegistration';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();
serviceWorkerRegistration.register();
```

### Service Worker 활성화 확인


### 로컬에서 확인하기
서비스 워커는 프로덕션 모드일 때만 활성화되기 때문에, 로컬 환경에서는 활성화 여부를 알 수 없습니다.
그래서 로컬에서 확인하기 위해, 리액트 애플리케이션을 프로덕션 버전으로 만들어 서빙합니다.

```bash
$ yarn global add serve
$ yarn build
$ serve -s build
```

## 프로젝트에서 PWA를 통해 얻은 것


## 마무리하며
다음 글에선 서비스워커와 WorkBox의 캐싱 전략을 알아보고, 이를 활용하여 웹페이지 로딩 속도 개선을 해보겠습니다.
이상, 글 읽어주셔서 감사합니다! 

<br>

